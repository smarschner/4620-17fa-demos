<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CS4620 View Explorer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
	<div id="container">
				<div id="controlBar" style="text-align: center;">
					<input type="file" id="meshInputFile" style="display: none;" onchange="loadFile(this.files[0])">
					<input type="button" id="meshInputButton" value="Select OBJ File" onclick="document.getElementById('meshInputFile').click()">
					<input type="file" id="texInputFile" style="display: none;" onchange="loadTexture(this.files[0])">
					<input type="button" id="texInputButton" value="Select Texture File" onclick="document.getElementById('texInputFile').click()">
					<label><input type="checkbox" id="showAxesCheckbox" onchange="toggleAxes(this.checked)" checked="true">Show Axes</label>
					<label><input type="checkbox" id="showWireframeCheckbox" onchange="toggleWireframe(this.checked)" checked="true">Show Wireframe</label>
					<br>
					Left click + drag to orbit. Right click + drag to pan. Scroll to zoom.
				</div>
				<table id="4views">
					<tr>
						<td><canvas id="cameraview" style="width:600; height:400"></canvas></td>
						<td><canvas id="worldspace" style="width:600; height:400"></canvas></td>
					</tr>
					<tr>
						<td><canvas id="eyespace" style="width:600; height:400"></canvas></td>
						<td><canvas id="clipspace" style="width:600; height:400"></canvas></td>
					</tr>
				</table>
	</div>

		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>

		<script>
			if (!Detector.webgl) {
				Detector.addGetWebGLMessage();
			}

			var group = null, backGroup = null, wireframeGroup = null;
			var scene, geomGroup, axesGroup, cubeGroup, lightGroup;
			var meshMaterial, backMaterial, wireframeMaterial;
			var cameraView, worldView, eyeView, clipView;

			init();
			animate();

			function makeWireCube() {
				var linePosns = [
					[-1, -1, -1],   [-1, -1,  1],
					[-1,  1, -1],   [-1,  1,  1],
					[ 1, -1, -1],   [ 1, -1,  1],
					[ 1,  1, -1],   [ 1,  1,  1],
					[-1, -1, -1],   [-1,  1, -1],
					[-1, -1,  1],   [-1,  1,  1],
					[ 1, -1, -1],   [ 1,  1, -1],
					[ 1, -1,  1],   [ 1,  1,  1],
					[-1, -1, -1],   [ 1, -1, -1],
					[-1, -1,  1],   [ 1, -1,  1],
					[-1,  1, -1],   [ 1,  1, -1],
					[-1,  1,  1],   [ 1,  1,  1],
				];
				// var geometry = new THREE.Geometry();
				// linePosns.forEach(function (a) {
				// 	geometry.vertices.push(new THREE.Vector3(a[0], a[1], a[2]));
				// 	geometry.
				// });
				// return new THREE.LineSegments(geometry, wireframeMaterial);	

				function pushVertex(g, a) {
					g.vertices.push(new THREE.Vector3(a[0], a[1], a[2]));
				}			

				// Stupid approach due to inability to make LineSegments work.
				var group = new THREE.Group();
				for (var i = 0; i < 12; i++) {
					var geometry = new THREE.Geometry();
					pushVertex(geometry, linePosns[2*i+0]);
					pushVertex(geometry, linePosns[2*i+1]);
					pushVertex(geometry, linePosns[2*i+0]);
					group.add(new THREE.Line(geometry, wireframeMaterial));
				}
				return group;
			}

			function addOBJGroup(OBJgroup) {
				if (group != null) {
					geomGroup.remove(group);
				}
				if (backGroup != null) {
					geomGroup.remove(backGroup);
				}
				if (wireframeGroup != null) {
					geomGroup.remove(wireframeGroup);
				}
				if (OBJgroup == null) {
					console.log("mesh is null");
					return;
				}

				group = OBJgroup;
				backGroup = OBJgroup.clone(true);
				wireframeGroup = OBJgroup.clone(true);
				geomGroup.add(group);
				geomGroup.add(backGroup);
				geomGroup.add(wireframeGroup);

				backGroup.children.map(function(object) {
					object.material = backMaterial;
				});

				wireframeGroup.children.map(function(object) {
					object.material = wireframeMaterial;
				});

			}

			function initView(canvasId) {
				var canvas = document.getElementById(canvasId);

				var near = (canvasId == 'cameraview') ? 1 : 0.1;
				var far = (canvasId == 'cameraview') ? 20 : 50;
				var camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, near, far);
				camera.position.z = 5;

				var renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true }); // WebGLRenderer CanvasRenderer
				renderer.setClearColor(0x707080);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(600, 400);

				var controls = new THREE.OrbitControls(camera, renderer.domElement);

				window.addEventListener('resize', onWindowResize, false);

				var self = {
					render: function () {
						// var tempLightGroup = lightGroup.clone(true);
						// scene.add(tempLightGroup);
						// tempLightGroup.applyMatrix(camera.matrix);

						// var tempCubeGroup = cubeGroup.clone(true);
						// scene.add(tempCubeGroup);
						// tempCubeGroup.applyMatrix(self.getCubeMatrix());

						lightGroup.matrix.copy(camera.matrix);
						geomGroup.matrix.copy(self.getGeomMatrix());
						cubeGroup.matrix.copy(self.getCubeMatrix());

						renderer.render(scene, camera);

						// scene.remove(tempCubeGroup);
						// scene.remove(tempLightGroup);
					},
					update: function () {
						controls.update();
					},
					getGeomMatrix: function () {
						return new THREE.Matrix4();
					},
					getCubeMatrix: function () {
						return new THREE.Matrix4();
					},
					getCameraMatrix: function () {
						return camera.matrixWorldInverse;
					},
					getProjMatrix: function () {
						return camera.projectionMatrix;
					}
				};

				return self;
			}

			function init() {
				views = ['cameraview', 'worldspace', 'eyespace', 'clipspace'].map(initView);
				views[2].getGeomMatrix = function () {
					return views[0].getCameraMatrix();
				}
				views[3].getGeomMatrix = function () {
					var projMatrix = views[0].getProjMatrix();
					return views[0].getCameraMatrix().clone().premultiply(projMatrix);
				}
				views[0].getCubeMatrix = function () {
					var cameraMatrix = views[0].getCameraMatrix();
					var projMatrix = views[0].getProjMatrix();
					var cameraProjMatrix = cameraMatrix.clone().premultiply(projMatrix);
					return new THREE.Matrix4().getInverse(cameraProjMatrix);
				}
				views[1].getCubeMatrix = function () { 
					var cameraMatrix = views[0].getCameraMatrix();
					var projMatrix = views[0].getProjMatrix();
					var cameraProjMatrix = cameraMatrix.clone().premultiply(projMatrix);
					return new THREE.Matrix4().getInverse(cameraProjMatrix);
				}
				views[2].getCubeMatrix = function () {
					var projMatrix = views[0].getProjMatrix();
					return new THREE.Matrix4().getInverse(projMatrix);
				}

				meshMaterial = new THREE.MeshLambertMaterial();
				meshMaterial.side = THREE.FrontSide;
				backMaterial = new THREE.MeshBasicMaterial({ color: 0xaaa000 });
				backMaterial.side = THREE.BackSide;
				wireframeMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true, transparent: true });

				scene = new THREE.Scene();

				axesGroup = new THREE.AxisHelper(1.5);
				scene.add(axesGroup);

				lightGroup = new THREE.Group();
				var light1 = new THREE.PointLight(0xffffff, 0.8);
				light1.position.set(50, 50, 100);
				lightGroup.add(light1);
				var light2 = new THREE.PointLight(0xeeeeff, 0.6);
				light2.position.set(-50, -50, -50);
				lightGroup.add(light2);
				lightGroup.matrixAutoUpdate = false;
				scene.add(lightGroup);

				cubeGroup = new THREE.Group();
				cubeGroup.add(makeWireCube());
				cubeGroup.matrixAutoUpdate = false;
				scene.add(cubeGroup);
				console.log(cubeGroup);

				geomGroup = new THREE.Group();
				geomGroup.matrixAutoUpdate = false;
				scene.add(geomGroup);

				// Account for cached state in some browsers
				document.getElementById('showAxesCheckbox').onchange();
				document.getElementById('showWireframeCheckbox').onchange();
			}

			function onWindowResize() {
				// camera.aspect = window.innerWidth / window.innerHeight;
				// camera.updateProjectionMatrix();
				// renderer.setSize(window.innerWidth, window.innerHeight);
			}

			var i = 0;
			function animate() {
				// if (i++ < 10) 
				requestAnimationFrame(animate);
				views.forEach(function (view) {
					view.update();
					render();
				});
			}

			function render() {
				views.forEach(function (view) { 
					view.render(); 
				});
			}

			function loadFile(file) {
				var reader = new FileReader();
				reader.addEventListener('load', function(event) {
					var contents = event.target.result;
					var object = new THREE.OBJLoader().parse(contents);
					object.name = file.name;
					addOBJGroup(object);
				});
				reader.readAsText(file);
			}

			function loadTexture(file) {
				var reader = new FileReader();
				reader.addEventListener('load', function(event) {
					var contents = event.target.result;
					var loader = new THREE.TextureLoader();
					loader.load(contents, function(texture) {
						meshMaterial.map = texture;
						meshMaterial.needsUpdate = true;
					});
				});
				reader.readAsDataURL(file);
			}

			function toggleAxes(show) {
				if (show) {
					scene.add(axesGroup);
				} else {
					scene.remove(axesGroup);
				}
			}

			function toggleWireframe(show) {
				if (show) {
					wireframeMaterial.opacity = 1.0;
				} else {
					wireframeMaterial.opacity = 0.0;
				}
			}

		</script>
	</body>
</html>
